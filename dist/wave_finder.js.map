{"version":3,"sources":["webpack:///wave_finder.js","webpack:///webpack/bootstrap 9bf208380205381dc72a","webpack:///./src/index.js"],"names":["wavefinder","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_class","passabilityMatrix","this","Error","map","row","slice","START_CELL","UNVISITED_CELL","value","startX","startY","finishX","finishY","finder","findPath","propagateWave","restorePath","_this","resultPath","stepsMatrix","fill","newX","newY","step","x","y","_this2","currentX","currentY","addStep","push","undefined","reverse"],"mappings":"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","file":"wave_finder.js","sourcesContent":["var wavefinder =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"./\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * Classic wave path finding algorithm\n\t * Wiki: (https://en.wikipedia.org/wiki/Lee_algorithm)\n\t *\n\t * @author Andrey Zharikov & Nikolay Govorov\n\t *\n\t */\n\t\n\tmodule.exports = function () {\n\t  _createClass(_class, null, [{\n\t    key: 'findPath',\n\t\n\t    /**\n\t     * Static wrapper for findPath\n\t     *\n\t     * @param {array} passabilityMatrix\n\t     * @param {number} startX\n\t     * @param {number} startY\n\t     * @param {number} finishX\n\t     * @param {number} finishY\n\t     *\n\t     * @return {array} path\n\t     */\n\t\n\t    value: function findPath(passabilityMatrix, startX, startY, finishX, finishY) {\n\t      var finder = new this(passabilityMatrix);\n\t\n\t      return finder.findPath(startX, startY, finishX, finishY);\n\t    }\n\t\n\t    /**\n\t     * Constructor requires passability matrix\n\t     *\n\t     * @param {array} passabilityMatrix - two-dimensional boolean array\n\t     *                true: passable cell, false: non-passable\n\t     *                other truthy and falsy values can be used as well:\n\t     *                Example: [ 1, 1, 1 ]\n\t     *                         [ 0, 0, 1 ]\n\t     *                         [ 1, 0, 1 ]\n\t     *\n\t     * @return {undefined}\n\t     */\n\t\n\t  }]);\n\t\n\t  function _class(passabilityMatrix) {\n\t    _classCallCheck(this, _class);\n\t\n\t    if ((typeof passabilityMatrix === 'undefined' ? 'undefined' : _typeof(passabilityMatrix)) !== 'object') {\n\t      throw new Error('Incorrect matrix!');\n\t    } else {\n\t      this.passabilityMatrix = passabilityMatrix.map(function (row) {\n\t        return row.slice();\n\t      });\n\t    }\n\t\n\t    this.START_CELL = 0;\n\t    this.UNVISITED_CELL = -1;\n\t  }\n\t\n\t  /**\n\t   * The function is a wrapper over functions propagateWave and restorePath.\n\t   *\n\t   * @param {number} startX\n\t   * @param {number} startY\n\t   * @param {number} finishX\n\t   * @param {number} finishY\n\t   *\n\t   * @return {array} If there is a way the function will return an array of objects with\n\t   *                 two fields (x and y), including the start and end points.\n\t   *                 Example: [ { x: 0, y: 0 }, { x: 0, y: 1 }, { x: 0, y: 2 }, { x: 0, y: 3 },\n\t   *                            { x: 0, y: 4 }, { x: 1, y: 4 }, { x: 2, y: 4 }, { x: 3, y: 4 } ]\n\t   *                 If there is no way it will return null.\n\t   */\n\t\n\t  _createClass(_class, [{\n\t    key: 'findPath',\n\t    value: function findPath(startX, startY, finishX, finishY) {\n\t      this.propagateWave(startX, startY);\n\t\n\t      return this.restorePath(finishX, finishY);\n\t    }\n\t\n\t    /**\n\t     * The function will propagate the wave. This is the second stage of the wave algorithm.\n\t     *\n\t     * @param {number} startX\n\t     * @param {number} startY\n\t     *\n\t     * @return {array} Wave array with minimum possible steps number for each reachable cell\n\t     */\n\t\n\t  }, {\n\t    key: 'propagateWave',\n\t    value: function propagateWave(startX, startY) {\n\t      var _this = this;\n\t\n\t      this.resultPath = [];\n\t\n\t      // first part of the wave algorithm - matrix initialization\n\t      this.stepsMatrix = this.passabilityMatrix.map(function (row) {\n\t        return row.slice().fill(_this.UNVISITED_CELL);\n\t      });\n\t      this.stepsMatrix[startX][startY] = this.START_CELL;\n\t\n\t      // second part of the wave algorithm - wave propagation\n\t      var propagateWave = function propagateWave(newX, newY, step) {\n\t        if (_this.passabilityMatrix[newX] && _this.passabilityMatrix[newX][newY]) {\n\t          if (_this.stepsMatrix[newX][newY] === _this.UNVISITED_CELL) {\n\t            _this.stepsMatrix[newX][newY] = step + 1;\n\t          }\n\t        }\n\t      };\n\t\n\t      for (var step = 0; step < this.stepsMatrix.length * this.stepsMatrix[0].length; step++) {\n\t        for (var x = 0; x < this.stepsMatrix.length; x++) {\n\t          for (var y = 0; y < this.stepsMatrix[0].length; y++) {\n\t            if (this.stepsMatrix[x][y] === step) {\n\t              propagateWave(x, y + 1, step); // up\n\t              propagateWave(x + 1, y, step); // right\n\t              propagateWave(x, y - 1, step); // down\n\t              propagateWave(x - 1, y, step); // left\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return this.stepsMatrix;\n\t    }\n\t\n\t    /**\n\t     * This method will restore the path on the basis of waves from a point which came to zero.\n\t     * Execute this method after method propagateWave. This is the third step of the wave algorithm.\n\t     *\n\t     * @param {number} finishX\n\t     * @param {number} finishY\n\t     *\n\t     * @return {array} If path was found, function will return path\n\t     *                 as an array of objects with cell coordinates,\n\t     *                 including the start and end points.\n\t     *                 Example: [ { x: 0, y: 0 }, { x: 0, y: 1 }, { x: 0, y: 2 }, { x: 0, y: 3 },\n\t     *                            { x: 0, y: 4 }, { x: 1, y: 4 }, { x: 2, y: 4 }, { x: 3, y: 4 } ]\n\t     *                 Returns null if there is no path.\n\t     */\n\t\n\t  }, {\n\t    key: 'restorePath',\n\t    value: function restorePath(finishX, finishY) {\n\t      var _this2 = this;\n\t\n\t      if (this.stepsMatrix[finishX][finishY] === this.UNVISITED_CELL) {\n\t        this.resultPath = null;\n\t        return null;\n\t      }\n\t\n\t      this.resultPath = [];\n\t\n\t      var currentX = finishX;\n\t      var currentY = finishY;\n\t\n\t      var addStep = function addStep(x, y) {\n\t        _this2.resultPath.push({ x: x, y: y });\n\t      };\n\t\n\t      addStep(finishX, finishY);\n\t\n\t      var propagateWave = function propagateWave(newX, newY, step) {\n\t        if (_this2.stepsMatrix[newX] !== undefined) {\n\t          if (_this2.stepsMatrix[newX][newY] === step - 1) {\n\t            addStep(newX, newY);\n\t            currentX = newX;\n\t            currentY = newY;\n\t            if (step === 1) return true;\n\t          }\n\t        }\n\t        return false;\n\t      };\n\t\n\t      for (var step = this.stepsMatrix[finishX][finishY]; step >= 0; step--) {\n\t        if (propagateWave(currentX + 1, currentY, step) || propagateWave(currentX - 1, currentY, step) || propagateWave(currentX, currentY + 1, step) || propagateWave(currentX, currentY - 1, step)) {\n\t          return this.resultPath.reverse();\n\t        }\n\t      }\n\t    }\n\t  }]);\n\t\n\t  return _class;\n\t}();\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** wave_finder.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"./\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 9bf208380205381dc72a\n **/","/**\n * Classic wave path finding algorithm\n * Wiki: (https://en.wikipedia.org/wiki/Lee_algorithm)\n *\n * @author Andrey Zharikov & Nikolay Govorov\n *\n */\n\nmodule.exports = class {\n  /**\n   * Static wrapper for findPath\n   *\n   * @param {array} passabilityMatrix\n   * @param {number} startX\n   * @param {number} startY\n   * @param {number} finishX\n   * @param {number} finishY\n   *\n   * @return {array} path\n   */\n\n  static findPath(passabilityMatrix, startX, startY, finishX, finishY) {\n    const finder = new this(passabilityMatrix);\n\n    return finder.findPath(startX, startY, finishX, finishY);\n  }\n\n  /**\n   * Constructor requires passability matrix\n   *\n   * @param {array} passabilityMatrix - two-dimensional boolean array\n   *                true: passable cell, false: non-passable\n   *                other truthy and falsy values can be used as well:\n   *                Example: [ 1, 1, 1 ]\n   *                         [ 0, 0, 1 ]\n   *                         [ 1, 0, 1 ]\n   *\n   * @return {undefined}\n   */\n\n  constructor(passabilityMatrix) {\n    if (typeof passabilityMatrix !== 'object') {\n      throw new Error('Incorrect matrix!');\n    } else {\n      this.passabilityMatrix = passabilityMatrix.map(row => row.slice());\n    }\n\n    this.START_CELL = 0;\n    this.UNVISITED_CELL = -1;\n  }\n\n  /**\n   * The function is a wrapper over functions propagateWave and restorePath.\n   *\n   * @param {number} startX\n   * @param {number} startY\n   * @param {number} finishX\n   * @param {number} finishY\n   *\n   * @return {array} If there is a way the function will return an array of objects with\n   *                 two fields (x and y), including the start and end points.\n   *                 Example: [ { x: 0, y: 0 }, { x: 0, y: 1 }, { x: 0, y: 2 }, { x: 0, y: 3 },\n   *                            { x: 0, y: 4 }, { x: 1, y: 4 }, { x: 2, y: 4 }, { x: 3, y: 4 } ]\n   *                 If there is no way it will return null.\n   */\n\n  findPath(startX, startY, finishX, finishY) {\n    this.propagateWave(startX, startY);\n\n    return this.restorePath(finishX, finishY);\n  }\n\n  /**\n   * The function will propagate the wave. This is the second stage of the wave algorithm.\n   *\n   * @param {number} startX\n   * @param {number} startY\n   *\n   * @return {array} Wave array with minimum possible steps number for each reachable cell\n   */\n\n  propagateWave(startX, startY) {\n    this.resultPath = [];\n\n    // first part of the wave algorithm - matrix initialization\n    this.stepsMatrix = this.passabilityMatrix.map(row => row.slice().fill(this.UNVISITED_CELL));\n    this.stepsMatrix[startX][startY] = this.START_CELL;\n\n    // second part of the wave algorithm - wave propagation\n    const propagateWave = (newX, newY, step) => {\n      if (this.passabilityMatrix[newX] && this.passabilityMatrix[newX][newY]) {\n        if (this.stepsMatrix[newX][newY] === this.UNVISITED_CELL) {\n          this.stepsMatrix[newX][newY] = step + 1;\n        }\n      }\n    };\n\n    for (let step = 0; step < this.stepsMatrix.length * this.stepsMatrix[0].length; step++) {\n      for (let x = 0; x < this.stepsMatrix.length; x++) {\n        for (let y = 0; y < this.stepsMatrix[0].length; y++) {\n          if (this.stepsMatrix[x][y] === step) {\n            propagateWave(x, y + 1, step); // up\n            propagateWave(x + 1, y, step); // right\n            propagateWave(x, y - 1, step); // down\n            propagateWave(x - 1, y, step); // left\n          }\n        }\n      }\n    }\n\n    return this.stepsMatrix;\n  }\n\n  /**\n   * This method will restore the path on the basis of waves from a point which came to zero.\n   * Execute this method after method propagateWave. This is the third step of the wave algorithm.\n   *\n   * @param {number} finishX\n   * @param {number} finishY\n   *\n   * @return {array} If path was found, function will return path\n   *                 as an array of objects with cell coordinates,\n   *                 including the start and end points.\n   *                 Example: [ { x: 0, y: 0 }, { x: 0, y: 1 }, { x: 0, y: 2 }, { x: 0, y: 3 },\n   *                            { x: 0, y: 4 }, { x: 1, y: 4 }, { x: 2, y: 4 }, { x: 3, y: 4 } ]\n   *                 Returns null if there is no path.\n   */\n\n  restorePath(finishX, finishY) {\n    if (this.stepsMatrix[finishX][finishY] === this.UNVISITED_CELL) {\n      this.resultPath = null;\n      return null;\n    }\n\n    this.resultPath = [];\n\n    let currentX = finishX;\n    let currentY = finishY;\n\n    const addStep = (x, y) => {\n      this.resultPath.push({ x, y });\n    };\n\n    addStep(finishX, finishY);\n\n    const propagateWave = (newX, newY, step) => {\n      if (this.stepsMatrix[newX] !== undefined) {\n        if (this.stepsMatrix[newX][newY] === step - 1) {\n          addStep(newX, newY);\n          currentX = newX;\n          currentY = newY;\n          if (step === 1) return true;\n        }\n      }\n      return false;\n    };\n\n    for (let step = this.stepsMatrix[finishX][finishY]; step >= 0; step--) {\n      if (\n        propagateWave(currentX + 1, currentY, step) ||\n        propagateWave(currentX - 1, currentY, step) ||\n        propagateWave(currentX, currentY + 1, step) ||\n        propagateWave(currentX, currentY - 1, step)\n      ) {\n        return this.resultPath.reverse();\n      }\n    }\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/"],"sourceRoot":""}